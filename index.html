<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OrbitalGuard - Precision Debris Tracker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/5.0.0/satellite.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #050510; color: #e0e0e0; font-family: 'Segoe UI', Roboto, Helvetica, sans-serif; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; z-index: 0; }
        
        /* Glassmorphism Sidebar */
        .sidebar { 
            position: fixed; top: 0; left: 0; width: 340px; height: 100vh; 
            background: rgba(15, 23, 42, 0.85); border-right: 1px solid rgba(255,255,255,0.1); 
            z-index: 10; display: flex; flex-direction: column; 
            backdrop-filter: blur(12px); box-shadow: 5px 0 25px rgba(0,0,0,0.5);
        }
        
        .sidebar-header { 
            padding: 24px; 
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .logo { 
            font-size: 24px; font-weight: 800; letter-spacing: -0.5px;
            background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
            margin-bottom: 8px;
        }
        
        .status-badge { 
            display: inline-flex; align-items: center; gap: 8px; 
            padding: 4px 10px; background: rgba(34, 197, 94, 0.1); 
            border: 1px solid rgba(34, 197, 94, 0.2); border-radius: 20px;
            font-size: 11px; color: #4ade80; font-weight: 600;
        }
        .status-dot { width: 6px; height: 6px; background: #4ade80; border-radius: 50%; box-shadow: 0 0 8px #4ade80; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }
        
        /* Stats Grid */
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; padding: 20px; }
        .stat-card { 
            background: rgba(255,255,255,0.03); padding: 15px; border-radius: 12px; 
            border: 1px solid rgba(255,255,255,0.05); text-align: center;
            transition: transform 0.2s;
        }
        .stat-card:hover { transform: translateY(-2px); background: rgba(255,255,255,0.05); }
        .stat-val { font-size: 24px; font-weight: 700; display: block; margin-bottom: 4px; }
        .stat-lbl { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #94a3b8; }
        .txt-blue { color: #60a5fa; }
        .txt-red { color: #f87171; }

        /* Controls Area */
        .controls-area { padding: 0 20px 20px; }
        
        .search-box { position: relative; margin-bottom: 15px; }
        .search-input { 
            width: 100%; background: rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); 
            border-radius: 8px; padding: 12px 15px 12px 15px; color: #fff; font-size: 14px; 
            transition: all 0.2s;
        }
        .search-input:focus { outline: none; border-color: #60a5fa; background: rgba(0,0,0,0.4); }
        
        .toggles { display: flex; gap: 15px; margin-bottom: 10px; }
        .toggle { display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; color: #cbd5e1; }
        .toggle input { accent-color: #60a5fa; }

        /* Satellite List */
        .list-container { flex: 1; overflow-y: auto; padding: 0 10px; }
        .list-container::-webkit-scrollbar { width: 4px; }
        .list-container::-webkit-scrollbar-track { background: transparent; }
        .list-container::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }

        .sat-item { 
            padding: 12px 15px; border-bottom: 1px solid rgba(255,255,255,0.05); 
            cursor: pointer; transition: all 0.2s; border-radius: 6px; margin-bottom: 2px;
        }
        .sat-item:hover { background: rgba(255,255,255,0.05); }
        .sat-item.active { background: rgba(96, 165, 250, 0.15); border-left: 3px solid #60a5fa; }
        
        .sat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .sat-name { font-weight: 600; font-size: 13px; color: #f1f5f9; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        .sat-type { font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 4px; }
        .type-deb { background: rgba(248, 113, 113, 0.2); color: #fca5a5; }
        .type-act { background: rgba(96, 165, 250, 0.2); color: #93c5fd; }
        .sat-id { font-size: 11px; color: #64748b; font-family: 'SF Mono', monospace; }

        /* HUD Elements */
        .hud-panel { 
            position: fixed; bottom: 30px; right: 30px; width: 300px; 
            background: rgba(15, 23, 42, 0.9); border: 1px solid rgba(255,255,255,0.1); 
            border-radius: 16px; padding: 20px; z-index: 20; backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transform: translateY(20px); opacity: 0; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }
        .hud-panel.visible { transform: translateY(0); opacity: 1; pointer-events: auto; }

        .hud-header { display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .hud-title { font-size: 16px; font-weight: 700; color: #fff; }
        .hud-close { background: none; border: none; color: #64748b; font-size: 20px; cursor: pointer; padding: 0; line-height: 1; }
        .hud-close:hover { color: #fff; }

        .hud-grid { display: grid; gap: 12px; }
        .hud-row { display: flex; justify-content: space-between; font-size: 13px; }
        .hud-lbl { color: #94a3b8; }
        .hud-val { font-family: 'SF Mono', monospace; color: #e2e8f0; }
        .val-alt { color: #60a5fa; }
        .val-vel { color: #a78bfa; }

        /* LLM Section Styles */
        .llm-section { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .llm-btn {
            width: 100%; background: #a78bfa; border: none; color: #fff; 
            padding: 10px; border-radius: 8px; font-weight: 600; cursor: pointer; 
            transition: background 0.2s; box-shadow: 0 4px 10px rgba(167, 139, 250, 0.4);
        }
        .llm-btn:hover { background: #8b5cf6; }
        .briefing-output { 
            margin-top: 10px; font-size: 12px; line-height: 1.5; color: #cbd5e1; 
            padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px;
            max-height: 150px; overflow-y: auto;
        }
        .loader-briefing { 
            margin-top: 10px; font-size: 12px; color: #a78bfa; text-align: center;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .loader-briefing::before {
            content: '';
            width: 12px; height: 12px; border: 2px solid rgba(167, 139, 250, 0.2);
            border-top-color: #a78bfa; border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Speed & Time Controls */
        .time-controls {
            position: fixed; bottom: 30px; left: 370px;
            background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px; padding: 10px 20px; z-index: 20;
            display: flex; align-items: center; gap: 20px; backdrop-filter: blur(8px);
        }
        
        .time-display { font-family: 'SF Mono', monospace; font-size: 14px; color: #60a5fa; min-width: 160px; text-align: center; }
        
        .speed-btns { display: flex; gap: 5px; background: rgba(0,0,0,0.2); padding: 4px; border-radius: 8px; }
        .speed-btn { 
            background: transparent; border: none; color: #94a3b8; 
            padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; 
            cursor: pointer; transition: all 0.2s;
        }
        .speed-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .speed-btn.active { background: #3b82f6; color: #fff; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4); }

        /* Loading Overlay */
        .loader { 
            position: fixed; inset: 0; background: #020617; z-index: 100; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            transition: opacity 0.5s;
        }
        .spinner { 
            width: 50px; height: 50px; border: 4px solid rgba(96, 165, 250, 0.1); 
            border-left-color: #60a5fa; border-radius: 50%; animation: spin 1s linear infinite; 
            margin-bottom: 20px;
        }
        .loader-text { font-family: 'SF Mono', monospace; color: #60a5fa; font-size: 14px; letter-spacing: 2px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Reset Cam Button */
        .reset-cam {
            position: fixed; top: 30px; right: 30px;
            background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(255,255,255,0.1);
            color: #fff; width: 40px; height: 40px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            transition: all 0.2s; z-index: 20;
        }
        .reset-cam:hover { background: #3b82f6; border-color: #3b82f6; }

    </style>
</head>
<body>
    <div class="loader" id="loader">
        <div class="spinner"></div>
        <div class="loader-text">FETCHING CRITICAL ORBITAL DATA...</div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="sidebar">
        <div class="sidebar-header">
            <div class="logo">OrbitalGuard</div>
            <div class="status-badge"><span class="status-dot"></span>LIVE CELESTRAK DATA</div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <span class="stat-val txt-blue" id="activeCount">0</span>
                <span class="stat-lbl">Active Sats</span>
            </div>
            <div class="stat-card">
                <span class="stat-val txt-red" id="debrisCount">0</span>
                <span class="stat-lbl">Debris Objects</span>
            </div>
        </div>

        <div class="controls-area">
            <div class="search-box">
                <input type="text" class="search-input" id="searchInput" placeholder="Search NORAD ID or Name...">
            </div>
            <div class="toggles">
                <label class="toggle"><input type="checkbox" id="showActive" checked> Satellites</label>
                <label class="toggle"><input type="checkbox" id="showDebris" checked> Debris</label>
            </div>
        </div>

        <div class="list-container" id="satList">
            </div>
    </div>

    <div class="hud-panel" id="hud">
        <div class="hud-header">
            <div>
                <div class="hud-title" id="hudName">SAT NAME</div>
                <div class="hud-lbl" id="hudId">#00000</div>
            </div>
            <button class="hud-close" onclick="deselectSat()">×</button>
        </div>
        <div class="hud-grid">
            <div class="hud-row"><span>Altitude</span><span class="hud-val val-alt" id="hudAlt">0 km</span></div>
            <div class="hud-row"><span>Velocity</span><span class="hud-val val-vel" id="hudVel">0 km/s</span></div>
            <div class="hud-row"><span>Latitude</span><span class="hud-val" id="hudLat">0°</span></div>
            <div class="hud-row"><span>Longitude</span><span class="hud-val" id="hudLon">0°</span></div>
            <div class="hud-row"><span>Period</span><span class="hud-val" id="hudPeriod">0 min</span></div>
        </div>
        
        <div class="llm-section">
            <button id="briefingBtn" class="llm-btn" onclick="requestBriefing()">Orbital Briefing</button>
            <div id="briefingLoader" class="loader-briefing" style="display: none;">Analyzing data...</div>
            <div id="briefingOutput" class="briefing-output"></div>
        </div>
        </div>

    <div class="time-controls">
        <div class="time-display" id="clock">00:00:00 UTC</div>
        <div class="speed-btns">
            <button class="speed-btn active" onclick="setSpeed(1)">REALTIME</button>
            <button class="speed-btn" onclick="setSpeed(10)">10×</button>
            <button class="speed-btn" onclick="setSpeed(100)">100×</button>
            <button class="speed-btn" onclick="setSpeed(1000)">1000×</button>
        </div>
    </div>

    <button class="reset-cam" onclick="resetCamera()" title="Reset Camera">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/>
        </svg>
    </button>

    <script>
        // --- Gemini API Configuration ---
        const API_MODEL = "gemini-2.5-flash"; 
        const apiKey = ""; 

        // --- Configuration ---
        const EARTH_RADIUS = 6371;
        const SCENE_SCALE = 0.001;
        
        // --- TLE Sources: REDUCED DEBRIS CATALOGS FOR PERFORMANCE ---
        const ALL_TLE_URLS = [
            // Active Sats - Stations is the most reliable (contains ISS)
            { type: 'ACTIVE', group: 'CRITICAL', url: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=stations&FORMAT=tle' }, 
            
            // Background Active Sats
            { type: 'ACTIVE', group: 'BACKGROUND', url: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=active&FORMAT=tle' }, 
            { type: 'ACTIVE', group: 'BACKGROUND', url: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=starlink&FORMAT=tle' },
            { type: 'ACTIVE', group: 'BACKGROUND', url: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=iridium-NEXT&FORMAT=tle' },

            // Background Debris Catalogs
            { type: 'DEBRIS', group: 'BACKGROUND', url: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=cosmos-2251-debris&FORMAT=tle' },
            { type: 'DEBRIS', group: 'BACKGROUND', url: 'https://celestrak.org/NORAD/elements/gp.php?GROUP=fengyun-1c-debris&FORMAT=tle' }, 
        ];

        // --- State ---
        let scene, camera, renderer, earth, atmosphere, satPoints;
        let satellites = []; 
        let displayedSats = []; 
        let selectedSat = null;
        let lastSatUpdate = 0; 
        
        // Time Management
        let timeOffset = 0;
        let timeSpeed = 1;
        let lastFrameTime = Date.now();
        let isRealtime = true;

        // Camera Interactions
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotation = { x: 0.5, y: 0.5 }; 

        // --- Gemini LLM Functions (Unchanged) ---

        async function fetchWithRetry(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status !== 429) return response;
                    
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    console.warn(`Rate limit hit (429). Retrying in ${delay.toFixed(0)}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } catch (error) {
                    console.error("Fetch attempt failed:", error);
                    if (i === maxRetries - 1) throw error;
                }
            }
            throw new Error("Max retries exceeded for API call.");
        }

        async function fetchGeminiContent(userQuery, systemPrompt) {
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            const response = await fetchWithRetry(apiUrl, options);
            
            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 && result.candidates[0].content?.parts?.[0]?.text) {
                return result.candidates[0].content.parts[0].text;
            } else {
                throw new Error(result.error?.message || "LLM response was empty.");
            }
        }
        
        window.requestBriefing = async () => {
            if (!selectedSat) return;

            const loader = document.getElementById('briefingLoader');
            const output = document.getElementById('briefingOutput');
            const button = document.getElementById('briefingBtn');

            output.innerHTML = '';
            loader.style.display = 'flex';
            button.disabled = true;

            try {
                const sat = selectedSat;
                const pos = getSatellitePos(sat, new Date(Date.now() + timeOffset));
                
                if (!pos) {
                    output.innerText = "Error: Cannot propagate orbit for this object.";
                    return;
                }

                const systemPrompt = "You are Orbital Analyst AI. Provide a concise, single-paragraph briefing (max 80 words) about the selected orbital object. If it is a known satellite, describe its mission. If it is 'Debris' or an unknown object (like R/B), explain generally what it likely is (e.g. rocket body, fragment) and the risks of this type of debris. Do not refuse to answer.";
                
                const userQuery = `Generate a briefing for: Object Name: ${sat.name}, NORAD ID: ${sat.id}. It is a ${sat.type}. Current orbital parameters: Altitude ${pos.alt.toFixed(1)} km, Velocity ${pos.vel.toFixed(2)} km/s.`;

                const briefingText = await fetchGeminiContent(userQuery, systemPrompt);
                
                output.innerText = briefingText;
                
            } catch (e) {
                console.error("Gemini API Error:", e);
                output.innerText = `Briefing failed: ${e.message}`;
            } finally {
                loader.style.display = 'none';
                button.disabled = false;
            }
        };

        // --- Initialization (Unchanged) ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // --- Earth Geometry and Materials (High Resolution) ---
            const loader = new THREE.TextureLoader();
            
            const earthGeo = new THREE.SphereGeometry(EARTH_RADIUS * SCENE_SCALE, 64, 64); 
            
            const dayMap = loader.load('https://unpkg.com/three-globe@2.24.13/example/img/earth-blue-marble.jpg');
            const bumpMap = loader.load('https://unpkg.com/three-globe@2.24.13/example/img/earth-topology.png');
            const specMap = loader.load('https://unpkg.com/three-globe@2.24.13/example/img/earth-water.png');

            const dayMat = new THREE.MeshPhongMaterial({
                map: dayMap,
                bumpMap: bumpMap,
                bumpScale: 0.2,
                specularMap: specMap,
                specular: new THREE.Color(0x333333),
                shininess: 20 
            });
            
            earth = new THREE.Mesh(earthGeo, dayMat);
            
            const nightMap = loader.load('https://unpkg.com/three-globe@2.24.13/example/img/earth-night.jpg');
            const nightMat = new THREE.MeshBasicMaterial({
                map: nightMap,
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.9
            });
            const nightMesh = new THREE.Mesh(earthGeo, nightMat);
            
            earth.add(nightMesh); 
            scene.add(earth);

            // Atmosphere Halo 
            const atmoGeo = new THREE.SphereGeometry(EARTH_RADIUS * SCENE_SCALE * 1.015, 64, 64);
            const atmoMat = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                        gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                    }
                `,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true
            });
            atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
            scene.add(atmosphere);

            // Starfield
            const starGeo = new THREE.BufferGeometry();
            const starCount = 3000; // Reduced for performance
            const starPos = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) {
                starPos[i] = (Math.random() - 0.5) * 600;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2, transparent:true, opacity:0.6});
            scene.add(new THREE.Points(starGeo, starMat));

            // Lighting
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(50, 20, 30);
            scene.add(sunLight);
            scene.add(new THREE.AmbientLight(0x404040, 0.5));

            // Container for Satellite Points
            satPoints = new THREE.Group();
            scene.add(satPoints);

            // Event Listeners
            window.addEventListener('resize', onResize);
            setupInteraction();
            
            // Start Data Fetch
            loadData();
            
            // Start Loop
            animate();
        }

        // --- Data Parsing Helper ---
        function parseTleData(dataArray) {
             let newSats = [];
             let parsedCount = 0;
             dataArray.forEach(res => {
                const lines = res.data.split('\n');
                for(let i=0; i<lines.length-2; i+=3) {
                    const name = lines[i].trim();
                    const l1 = lines[i+1].trim();
                    const l2 = lines[i+2].trim();
                    
                    try {
                        const satrec = satellite.twoline2satrec(l1, l2);
                        if (!satrec.error) {
                            newSats.push({
                                id: satrec.satnum,
                                name: name,
                                type: res.type,
                                satrec: satrec,
                                period: (2 * Math.PI) / satrec.no
                            });
                            parsedCount++;
                        }
                    } catch(e) {}
                }
            });
            return { newSats, parsedCount };
        }


        // --- Data Orchestration with TWO STAGES ---
        async function loadData() {
            const CACHE_KEY = 'orbital_data_cache_v5'; // NEW CACHE KEY to force a fresh, resilient load
            const CACHE_DURATION = 12 * 60 * 60 * 1000; 
            const loaderText = document.querySelector('.loader-text');

            const criticalUrls = ALL_TLE_URLS.filter(s => s.group === 'CRITICAL');
            const backgroundUrls = ALL_TLE_URLS.filter(s => s.group === 'BACKGROUND');
            
            // 1. Check Cache First (Instant Load if successful)
            const cached = localStorage.getItem(CACHE_KEY);
            if (cached) {
                const parsedCache = JSON.parse(cached);
                if (Date.now() - parsedCache.timestamp < CACHE_DURATION) {
                    console.log("Loading from cache (INSTANT).");
                    
                    const { newSats } = parseTleData(parsedCache.data);
                    satellites = newSats;
                    
                    updateStats();
                    filterList();
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                    return; // Exit here, fast load successful
                }
            }

            // --- FIRST RUN: STAGE 1 (Critical - ISS/Stations) ---
            loaderText.innerText = "FETCHING CRITICAL ORBITAL DATA...";
            
            let allResponses = [];

            try {
                // Fetch and parse the critical (small) set first
                const criticalResponses = await Promise.all(criticalUrls.map(async src => {
                    try {
                        const response = await fetch(src.url);
                        return { type: src.type, data: await response.text() };
                    } catch(e) {
                        console.error(`Failed to fetch critical URL: ${src.url}`, e);
                        return { type: src.type, data: '' }; // Return empty data on failure
                    }
                }));
                
                const validCriticalResponses = criticalResponses.filter(res => res.data.length > 0);
                const { newSats: criticalSats } = parseTleData(validCriticalResponses);
                
                // Set the initial satellites list (ISS will be here)
                satellites = criticalSats;
                allResponses = validCriticalResponses;

                // Hide loader immediately to start rendering active sats
                updateStats();
                filterList();
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

                console.log(`Stage 1 Complete: Loaded ${criticalSats.length} critical satellites.`);

                // --- STAGE 2 (Background - Debris & Full Active) ---
                loaderText.innerText = "LOADING DEBRIS (Background)..."; // This text is now hidden
                
                const backgroundResponses = await Promise.all(backgroundUrls.map(async src => {
                    try {
                        const response = await fetch(src.url);
                        return { type: src.type, data: await response.text() };
                    } catch(e) {
                        console.error(`Failed to fetch background URL: ${src.url}`, e);
                        return { type: src.type, data: '' }; // Return empty data on failure
                    }
                }));
                
                const validBackgroundResponses = backgroundResponses.filter(res => res.data.length > 0);
                const { newSats: backgroundSats } = parseTleData(validBackgroundResponses);
                
                // Merge background data and save cache
                allResponses = allResponses.concat(validBackgroundResponses);
                localStorage.setItem(CACHE_KEY, JSON.stringify({
                    timestamp: Date.now(),
                    data: allResponses
                }));
                
                // Safely merge new data without losing critical sats
                satellites = satellites.concat(backgroundSats.filter(
                    bSat => !satellites.some(cSsat => cSsat.id === bSat.id) // Avoid duplicates
                ));
                
                // Update UI again to show the newly loaded debris clouds
                console.log(`Stage 2 Complete: Total satellites: ${satellites.length}`);
                updateStats(); 
                filterList(); 

            } catch (err) {
                // This catch handles critical failures (e.g., total network loss)
                loaderText.innerText = "ERROR LOADING DATA";
                console.error(err);
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
            }
        }


        // --- Physics & Propagation (Unchanged) ---
        function getSatellitePos(sat, date) {
            const positionAndVelocity = satellite.propagate(sat.satrec, date);
            const positionEci = positionAndVelocity.position;
            
            if (!positionEci) return null;

            const gmst = satellite.gstime(date);
            const positionGd = satellite.eciToGeodetic(positionEci, gmst);
            
            // Convert to ThreeJS Space
            const alt = positionGd.height;
            const R = (EARTH_RADIUS + alt) * SCENE_SCALE;
            const phi = positionGd.latitude;
            const theta = positionGd.longitude;

            const x = R * Math.cos(phi) * Math.cos(theta);
            const z = R * Math.cos(phi) * Math.sin(theta); 
            const y = R * Math.sin(phi);
            
            return {
                vec: new THREE.Vector3(x, y, z), 
                alt: alt,
                vel: Math.sqrt(Math.pow(positionAndVelocity.velocity.x, 2) + 
                               Math.pow(positionAndVelocity.velocity.y, 2) + 
                               Math.pow(positionAndVelocity.velocity.z, 2)),
                lat: satellite.degreesLat(phi),
                lon: satellite.degreesLong(theta)
            };
        }

        function updateSatelliteMeshes() {
            // Optimized: Clean memory
            while(satPoints.children.length > 0){
                const child = satPoints.children[0];
                if(child.geometry) child.geometry.dispose(); 
                if(child.material) child.material.dispose(); 
                satPoints.remove(child);
            }

            const now = isRealtime ? new Date() : new Date(Date.now() + timeOffset);

            const activeGeom = new THREE.BufferGeometry();
            const debrisGeom = new THREE.BufferGeometry();
            const activePos = [];
            const debrisPos = [];

            displayedSats.forEach(sat => {
                const posData = getSatellitePos(sat, now);
                if(posData) {
                    if(sat.type === 'ACTIVE') {
                        activePos.push(posData.vec.x, posData.vec.y, posData.vec.z);
                    } else {
                        debrisPos.push(posData.vec.x, posData.vec.y, posData.vec.z);
                    }
                }
            });

            if(activePos.length) {
                activeGeom.setAttribute('position', new THREE.Float32BufferAttribute(activePos, 3));
                const mat = new THREE.PointsMaterial({color: 0x60a5fa, size: 0.15, transparent: true, opacity: 0.8});
                satPoints.add(new THREE.Points(activeGeom, mat));
            }
            if(debrisPos.length) {
                debrisGeom.setAttribute('position', new THREE.Float32BufferAttribute(debrisPos, 3));
                const mat = new THREE.PointsMaterial({color: 0xf87171, size: 0.12, transparent: true, opacity: 0.6});
                satPoints.add(new THREE.Points(debrisGeom, mat));
            }
            
            // Highlight selected
            if(selectedSat) {
                const posData = getSatellitePos(selectedSat, now);
                if(posData) {
                    updateHud(selectedSat, posData);
                    const markerGeo = new THREE.SphereGeometry(0.1, 8, 8);
                    const markerMat = new THREE.MeshBasicMaterial({color: 0xffffff});
                    const marker = new THREE.Mesh(markerGeo, markerMat);
                    marker.position.copy(posData.vec);
                    satPoints.add(marker);
                }
            }

            document.getElementById('clock').innerText = now.toUTCString().split(' ')[4] + ' UTC';
        }

        // --- Interaction & UI (Unchanged) ---
        function updateStats() {
            const act = satellites.filter(s => s.type === 'ACTIVE').length;
            const deb = satellites.filter(s => s.type === 'DEBRIS').length;
            document.getElementById('activeCount').innerText = act;
            document.getElementById('debrisCount').innerText = deb;
        }

        function filterList() {
            const showActive = document.getElementById('showActive').checked;
            const showDebris = document.getElementById('showDebris').checked;
            const query = document.getElementById('searchInput').value.toLowerCase();

            displayedSats = satellites.filter(s => {
                const typeMatch = (s.type === 'ACTIVE' && showActive) || (s.type === 'DEBRIS' && showDebris);
                const queryMatch = !query || s.name.toLowerCase().includes(query) || s.id.includes(query);
                return typeMatch && queryMatch;
            });

            renderList();
        }

        function renderList() {
            const container = document.getElementById('satList');
            const fragment = document.createDocumentFragment();
            
            // Limit DOM nodes for performance
            displayedSats.slice(0, 100).forEach(sat => {
                const div = document.createElement('div');
                div.className = `sat-item ${selectedSat === sat ? 'active' : ''}`;
                div.innerHTML = `
                    <div class="sat-row">
                        <div class="sat-name">${sat.name}</div>
                        <div class="sat-type ${sat.type === 'ACTIVE'?'type-act':'type-deb'}">${sat.type === 'ACTIVE'?'SAT':'DEB'}</div>
                    </div>
                    <div class="sat-id">NORAD #${sat.id}</div>
                `;
                div.onclick = () => selectSat(sat);
                fragment.appendChild(div);
            });
            
            container.innerHTML = '';
            container.appendChild(fragment);
        }

        function selectSat(sat) {
            selectedSat = sat;
            document.getElementById('hud').classList.add('visible');
            document.getElementById('briefingOutput').innerText = ''; 
            document.getElementById('briefingLoader').style.display = 'none';
            renderList(); 
        }

        window.deselectSat = () => {
            selectedSat = null;
            document.getElementById('hud').classList.remove('visible');
            renderList();
        }

        function updateHud(sat, pos) {
            document.getElementById('hudName').innerText = sat.name;
            document.getElementById('hudId').innerText = '#' + sat.id;
            document.getElementById('hudAlt').innerText = pos.alt.toFixed(1) + ' km';
            document.getElementById('hudVel').innerText = pos.vel.toFixed(2) + ' km/s';
            document.getElementById('hudLat').innerText = pos.lat.toFixed(2) + '°';
            document.getElementById('hudLon').innerText = pos.lon.toFixed(2) + '°';
            document.getElementById('hudPeriod').innerText = (sat.period / 60).toFixed(0) + ' min'; 
        }

        // --- Inputs & Camera Controls (Unchanged) ---
        function setupInteraction() {
            const dom = renderer.domElement;
            
            dom.addEventListener('mousedown', e => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mousemove', e => {
                if(isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    targetRotation.y += deltaX * 0.005;
                    targetRotation.x += deltaY * 0.005;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            window.addEventListener('mouseup', () => isDragging = false);
            
            dom.addEventListener('wheel', e => {
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(10, Math.min(80, camera.position.z));
            });

            // Raycaster for 3D clicks
            const raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 0.5;
            
            dom.addEventListener('click', e => {
                if(Math.abs(e.clientX - previousMousePosition.x) > 2) return; 
                
                const mouse = new THREE.Vector2(
                    (e.clientX / window.innerWidth) * 2 - 1,
                    -(e.clientY / window.innerHeight) * 2 + 1
                );
                raycaster.setFromCamera(mouse, camera);
                
                const now = isRealtime ? new Date() : new Date(Date.now() + timeOffset);
                
                let closest = null;
                let minDist = Infinity;
                
                displayedSats.forEach(sat => {
                    const pos = getSatellitePos(sat, now);
                    if(pos) {
                        const vec = pos.vec.clone().project(camera);
                        const dist = vec.distanceTo(new THREE.Vector3(mouse.x, mouse.y, vec.z));
                        if(dist < 0.02 && dist < minDist && vec.z < 1) { 
                            minDist = dist;
                            closest = sat;
                        }
                    }
                });
                
                if(closest) selectSat(closest);
            });

            document.getElementById('searchInput').addEventListener('input', filterList);
            document.getElementById('showActive').addEventListener('change', filterList);
            document.getElementById('showDebris').addEventListener('change', filterList);
        }

        // --- Time Control Logic (Unchanged) ---
        window.setSpeed = (speed) => {
            timeSpeed = speed;
            document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            if(speed === 1) {
                isRealtime = true;
                timeOffset = 0;
            } else {
                isRealtime = false;
                timeOffset = (Date.now() + timeOffset) - Date.now(); 
            }
        };

        window.resetCamera = () => {
            camera.position.z = 30;
            targetRotation = { x: 0.5, y: 0.5 };
        };

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Main Loop (Unchanged) ---
        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const dt = now - lastFrameTime;
            lastFrameTime = now;

            if(!isRealtime) {
                timeOffset += dt * (timeSpeed - 1);
            }

            // 1. Earth Rotation (Always smooth 60fps)
            earth.rotation.y += (targetRotation.y - earth.rotation.y) * 0.1;
            earth.rotation.x += (targetRotation.x - earth.rotation.x) * 0.1;
            if(!isDragging) targetRotation.y += 0.0005;
            
            satPoints.rotation.copy(earth.rotation);
            atmosphere.rotation.copy(earth.rotation);

            // 2. Satellite Position Update (Throttled to 1 second to fix lag)
            if (now - lastSatUpdate > 1000) {
                updateSatelliteMeshes();
                lastSatUpdate = now;
            }

            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>

</html>
